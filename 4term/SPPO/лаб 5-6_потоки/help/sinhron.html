<HTML>
  <HEAD>
<title>Теоретическая справка. Синхронизация</title>
<link rel="stylesheet" type="text/css" href="style.css">
</HEAD>

 <BODY background="images\bg2.jpg">
&nbsp;&nbsp;&nbsp;&nbsp<font id="start"><b>Синхронизация</b></font>
<ul>
При написании многопотокового приложения может понадобиться синхронизация отдельных потоков с другими частями программы. Синхронизация является компромиссом между неструктурированной природой многопотокового программирования и структурированным порядком синхронной обработки.<br><br>
Синхронизация используется в следующих случаях:
<pre>
	- для явного управления порядком выполнения кода, если задачи должны выполняться
          в определенной последовательности;
	- для предотвращения проблем, возникающих при использовании одного ресурса 
          одновременно двумя потоками.
</pre>
Для этого используются объекты синхронизации и соответствующие механизмы.
<pre>
	- <a class = "pushLink" href="#semaphore">[<span>Семафор</span>]</a> (Semaphore)
	- <a class = "pushLink" href="#critical">[<span>Критическая секция</span>]</a> (Critical Section)
	- <a class = "pushLink" href="#mutex">[<span>Мьютекс</span>]</a> (Mutex)
	- <a class = "pushLink" href="#event">[<span>Событие</span>]</a> (Event)
	- <a class = "pushLink" href="#timer">[<span>Ожидаемый таймер</span>]</a> (Waitable Timer)
	- <a class = "pushLink" href="#monitor">[<span>Монитор</span>]</a> (Monitor)
</pre>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp<font id="semaphore"><b>Семафор</b></font>
<ul>
Объект-семафор - это фактически объект-взаимоисключение со счетчиком. Данный объект позволяет "захватить" себя определенному количеству потоков. После этого "захват" будет невозможен, пока один из ранее "захвативших" семафор-потоков не освободит его. Семафоры применяются для ограничения количества потоков, одновременно работающих с ресурсом. <br><br>Объекту при инициализации передается максимальное число потоков, после каждого "захвата" счетчик семафора уменьшается. Сигнальному состоянию соответствует значение счетчика больше нуля. Если счетчик равен нулю, семафор занят. Кроме того, система не допускает присвоения отрицательных значений счётчику, а также счетчик не может принимать значения большие установленного максимального количества потоков.<br><br>
Семафоры очень эффективны, поскольку они позволяют одновременный доступ к ресурсам.
</ul>
&nbsp;&nbsp;&nbsp;&nbsp<font id="critical"><b>Критическая секция</b></font>
<ul>
Этот синхронизирующий объект может использоваться только локально внутри процесса, создавшего его. Остальные объекты могут быть использованы для синхронизации потоков разных процессов. Название объекта “критическая секция” связано с некоторым абстрактным выделением части программного кода (секции), выполняющего некоторые операции, порядок которых не может быть нарушен. То есть попытка двумя разными потоками одновременно выполнять код этой секции приведет к ошибке.
<br><br>
Для критической секции вводят две операции:<br><br>
1) войти в секцию
<BLOCKQUOTE>Пока какой–либо поток находится в критической секции, все остальные потоки при попытке войти в нее будут автоматически останавливаться в ожидании. Поток, уже вошедший в эту секцию, может входить в нее многократно, не ожидая ее освобождения.</BLOCKQUOTE>
2) покинуть секцию
<BLOCKQUOTE>При покидании потоком секции уменьшается счетчик числа вхождений этого потока в секцию, так что секция будет освобождена для других потоков только если поток выйдет из секции столько раз, сколько раз в нее входил. При освобождении критической секции будет пробужден только один поток, ожидающий разрешения на вход в эту секцию.</BLOCKQUOTE>
При использовании критических секций надо следить, что бы в секции не выделялись чересчур большие фрагменты кода, так как это может привести к существенным задержкам в выполнении других потоков.
</ul>
&nbsp;&nbsp;&nbsp;&nbsp<font id="mutex"><b>Мьютекс</b></font>
<ul>
Объекты исключительного владения — mutex — могут принадлежать только одному потоку одновременно.<br><br> Соответственно определяются операции над этими объектами:<br><br>
1) затребовать владение объектом
<BLOCKQUOTE>При запросе владения система проверяет, владеет–ли какой–либо другой поток этим объектом или нет. Если имеется другой поток–владелец, то данный поток останавливается до тех пор, пока объект не освободиться. Как только объект становится свободным, система отдает его во владение новому потоку. Поток, уже владеющий объектом, может многократно вступать во владение им.</BLOCKQUOTE>
2) освободить объект
<BLOCKQUOTE>При освобождении объекта система просматривает, имеются–ли другие потоки, ожидающие освобождения этого объекта. Если имеются, то возобновит работу только один поток, а все остальные продолжат ожидание — объект mutex может быть во владении только у одного потока. Освобождать объект может только тот поток, который им в данный момент владеет, другие потоки этого сделать не могут. Для полного освобождения объекта поток должен столько раз освободить его, сколько раз он затребовал владение с того момента, как ему дали этот объект во владение.</BLOCKQUOTE>
Если учесть, что владеть объектом mutex может только один поток, то получается, что такие объекты похожи на критические секции — с того момента, как система отдала объект во владение потоку все остальные, которые захотят получить его во владение, будут ожидать его освобождения.<br><br>Отличия заключаются в некоторых нюансах использования — во–первых, объекты mutex могут быть использованы разными процессами (для этого предусмотрены именованные объекты, которые могут быть использованы другими процессами) и, во–вторых, ожидать владения этим объектом можно разными способами — с ограничением по времени или, например, использовать его для синхронизации сразу с несколькими объектами (другими объектами mutex, семафорами, событиями и прочим). 
</ul>
&nbsp;&nbsp;&nbsp;&nbsp<font id="event"><b>Событие</b></font>
<ul>
События - разновидность объектов ядра. Они содержат счетчик числа пользователей (как и все объекты ядра) и две булевы переменные: одна сообщает тип данного объекта-события, другая — его состояние. События просто уведомляют об окончании какой-либо операции. Объекты-события бывают двух типов: со сбросом вручную (manual-reset events) и с автосбросом (auto-reset events). <br><br>
События, как и объекты исключительного владения, могут использоваться для синхронизации потоков, принадлежащих разным приложениям. Самые значительные отличия сводятся к следующему:<br><br>
1) событиями никто не владеет — то есть устанавливать события в свободное или занятое состояние могут любые потоки, имеющие право доступа к этому объекту;<br><br>
2) события различают только два состояния — свободное и занятое. Сколько бы раз вы не переводили событие в занятое состояние, один единственный вызов функции, освобождающей это событие, освободит его. И наоборот;<br><br>
3) в классическом варианте освобождение события разрешает запуск всех потоков, ожидающих его. Объекты исключительного владения и критические секции позволяли возобновить исполнение только одного потока;<br><br>
4) смена состояния события осуществляется в любой момент времени. Так, для вхождения в критическую секцию или для получения объекта mutex во владение необходимо было дождаться их освобождения (что выполнялось автоматически). Для событий это не так.<br><br>
Соответственно, применительно к событиям, говорят о двух основных состояниях: <em>свободном</em> (установленном) и <em>занятом</em> (сброшенном) и о трех операциях, выполняемых над ними:<br><br>
1) сбросить событие
<BLOCKQUOTE>Событие в сброшенном состоянии считается занятым. Любой поток, имеющий доступ к событию, может сбросить его, независимо от того, какой поток это событие устанавливал.</BLOCKQUOTE>
2) установить (иногда — послать) событие
<BLOCKQUOTE>Установленное (посланное) событие считается свободным. Как только событие освобождается, все ожидающие его потоки могут возобновить свое исполнение. Устанавливать событие может также любой поток.</BLOCKQUOTE>
3) дождаться события
<BLOCKQUOTE>Так как сброс и установка событий происходит в любой момент времени, независимо от предыдущего состояния события, то приходится вводить специальную операцию — дождаться освобождения объекта.</BLOCKQUOTE>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp<font id="timer"><b>Ожидаемый таймер</b></font>
<ul>
Ожидаемые таймеры - это объекты ядра, которые самостоятельно переходят в свободное состояние в определенное время или через регулярные промежутки времени.Таймеры бывают, также как и события, с автосбросом и без него. Таймер переходит в сигнальное состояние, когда истекает его таймаут. 
</ul>
&nbsp;&nbsp;&nbsp;&nbsp<font id="monitor"><b>Монитор</b></font>
<ul>
Монитор - это средство обеспечения контроля за доступом к ресурсу. У монитора может быть только один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.
<br><br>
Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.
</ul>
&nbsp;&nbsp;&nbsp;&nbsp<b>Рекомендации</b>
<ul>
<li class="withborder">
1) Если приложения или потоки одного процесса изменяют общий ресурс -  защищайте доступ к нему при помощи критических секций или мьютексов.<br><br> 
2) Если доступ осуществляется только на чтение - защищать ресурс не обязательно.<br><br> 
3) Критические секции более эффективны, но применимы только внутри одного процесса; мьютексы могут использоваться для синхронизации между процессами. <br><br>
4) Используйте семафоры для ограничения количества обращений к одному ресурсу. <br><br>
5) Используйте события (event) для информирования потока о наступлении какого-либо события. 
6) Если разделяемый ресурс - 32-битная переменная, то для синхронизации доступа к нему можно использовать функции, обеспечивающие разделяемый доступ к переменным. <br><br>
7) Многие объекты Win32 позволяют организовать эффективное слежение за своим состоянием при помощи функций ожидания. Это наиболее эффективный с точки зрения расхода системных ресурсов метод. 
</ul>
<a class = "pushLink" href="#start">[<span>В начало документа</span>]</a><br>
<center><a class = "pushLink" href="index.html">[<span>Оглавление</span>]</center>
  </BODY>
</HTML>