<html>
<title>Методические указания</title>
<head><H2 ALIGN=CENTER>Методические указания к работе №6</H2></head>

<body BGCOLOR="#CFFFFF" TEXT="#000000" LINK="191970#">

<H3>Теоретический материал</H3>
<B><I>Последовательный порт.</B></I> Каждый компьютер оборудован, по меньшей мере, двумя последовательными портами, которые чаще всего используют для подключения мыши и модема, а также других дополнительных устройств или соединения компьютеров между собой. Для работы с устройствами, подключенными к портам, такими как мышь, применяются драйверы, которые общаются с последовательным портом непосредственно на уровне портов ввода/вывода и предоставляют программам некоторый набор функций более высокого уровня, так что прямая работа с последовательными портами оказывается необходимой только при написании таких драйверов, работе с нестандартными устройствами или модемами.
<P>При асинхронной связи машина посылает или принимает байты информации по одному биту. Временные интервалы между байтами при этом несущественны, но времена между отдельными битами байта очень важны. Сигнал на линии может быть высокого или низкого уровня, что соответствует логическим нулю и единице, и говорят, что линия отмечена (marking), когда уровень высокий, и пустая (spacing), когда уровень низкий. Линия поддерживается в отмеченном состоянии, когда по ней нет передачи данных. При начале передачи байта данных сигнал падает в 0, отмечая стартовый бит. Затем следуют восемь битов данных (иногда меньше) в виде набора высоких и низких уровней. Последний бит данных может сопровождаться битом четности, используемым для обнаружения ошибок, а затем в последовательность включаются 1 или более стоп-битов, которым соответствует высокий уровень. Эти стоп-биты начинают отмеченное состояние, которое будет сохраняться до тех пор, пока не начнется передача следующего байта данных; число используемых стоп-битов существенно, поскольку они устанавливают минимальное время, которое должно пройти перед следующим стартовым битом. Конечно, передающая и приемная станции должны использовать один и тот же протокол для этих цепочек битов и они должны работать с одной и той же скоростью обмена (измеряемой в битах в секунду, называемых также бодами). 
<P>При обмене могут легко возникать ошибки, поэтому коммуникационное оборудование предоставляет разнообразную информацию о статусе как самого порта, так и присоединенного к нему модема. Задачей модема является преобразование сигнала, генерируемого портом коммуникации, в акустический сигнал, который может затем быть передан по телефонному каналу. Большинство модемов предоставляют также дополнительные коммуникационные возможности, такие как автоматический вызов и ответ, которые не поддерживаются самим портом коммуникации.
<P><I>Инициализация последовательного порта.</I> При инициализации порта коммуникации ("открытии") устанавливаются все его параметры. Эти параметры длину слова, число стоп-битов, установку четности и скорость обмена. Длина слова это число битов, которое образует основную единицу данных. Если мы работаем с привычными порциями по 8 битов, то 7 битов достаточны для стандартных файлов ASCII (в которых все символы имеют коды, не превышающие ASCII 128), в то время как для передачи численных данных достаточно порций по 4 бита. 
<P>Функция 0 прерывания 14h BIOS инициализирует порт коммуникации. В DX должен даваться номер коммуникационного канала (COM1 =0, COM2 = 1). В AL должен содержаться байт инициализационных данных, значение битов которого следующее: 
<LI> биты 1-0 длина слова:
<P> 10 - 7 битов
<P> 1 - 8 битов
<LI>  2 число стоп-битов:
<P>0 - 1
<P>1 - 2 
<LI>  4-3 четность:
<P>00 или 10 - нет
<P>01 - нечетные
<P>11 - четные
<LI>  7-5 скорость обмена:
<P>000 - 110 бод 
<P>001 - 150 бод 
<P>010 - 300 бод 
<P>011 - 600 бод 
<P>100 - 1200 бод 
<P>101 - 2400 бод 
<P>110 - 4800 бод 
<P>111 - 9600 бод 
<P>В данном примере порт инициализируется со словом в 8 битов, одним стоп-битом и четной четностью, скорость обмена 1200 бод:

;присваиваем значения параметров переменным 
<P>mov wordlength,00000011b      ;длина слова 8 битов 
<P>mov stopbits,00000000b            ;1 стоп-бит
<P>mov parity,00011000b               ;четная четность
<P>mov baudrate,10000000b           ;скорость 1200 бод;
<P>;инициализируем COM1 
<P>mov al,0                                     ;чистим AL 
<P>or al, wordlenght                        ;устанавливаем нужные биты 
<P>or al,stopbits 
<P>or al,parity 
<P>or al,baudrate 
<P>mov ah,0                                      ;функция инициализации порта
<P>mov dx,0                                      ;выбираем COM1
<P>int 14h                                          ;инициализируем порт 

<P>Hезависимо от того, занимаемся ли мы вводом или выводом, как минимум 4 регистра микросхемы 8250 должны быть инициализированы для операций обмена. Это регистры делителя скорости обмена, регистр контроля линии и регистр разрешения прерывания. Инициализация скорости обмена. Делитель скорости обмена это число, на которое надо разделить частоту системных часов (1190000 герц), чтобы получить желаемую скорость обмена. Hапример, для скорости обмена 12 00 бод делитель скорости обмена должен быть равен 96, поскольку 1190000/96 приближенно равно 1200. Чем больше делитель, тем меньше скорость обмена. Скорости обмена 300 и меньше требуют двухбайтного числа для делителя. Старший байт посылается в 3F9H (или 2F9H), а младший в 3F8H (2F8H). В обоих случаях бит 7 регистра управления линии должен быть установлен в 1 перед засылкой значений; в противном случае по этим двум адресам значения будут адресованы в другие регистры. Вот некоторые значения, требуемые для обычных скоростей обмена: 
<TABLE BORDER=1>
<TR><TD>Скорость обмена</TD><TD>3F9H</TD><TD>   3F8H
<TR><TD>110 </TD><TD>04H</TD><TD>17H</TD></TR> 
<TR><TD>300</TD><TD> 01H </TD><TD>80H</TD></TR>
<TR><TD> 600</TD><TD> 00H</TD><TD> C0H</TD></TR>
<TR><TD> 1200</TD><TD> 00H</TD><TD> 60H</TD></TR> 
<TR><TD>1800 </TD><TD>00H</TD><TD> 40H</TD></TR>
<TR><TD> 2400</TD><TD> 00H</TD><TD> 30H</TD></TR>
<TR><TD> 3600 </TD><TD>00H</TD><TD> 20H</TD></TR>
<TR><TD> 4800</TD><TD> 00H</TD><TD> 18H</TD></TR>
<TR><TD> 9600</TD><TD> 00H</TD><TD> 0CH </TD></TR>
</TABLE> 

<P>Всегда надо устанавливать регистры скорости обмена первыми, так как они единственные, которые требуют, чтобы был установлен бит 7 в регистре контроля линии. После этого надо изменить содержимое регистра контроля линии, сбрасывая 7-й бит, чтобы все остальные доступы к регистрам были правильными. Поскольку регистр контроля линии является регистром только для записи, то нет способа вернуть бит 7 обратно в 1 без одновременной установки всех остальных битов этого регистра. Отметим, что PCjr использует другие делители, описание которых Вы можете найти в техническом руководстве.
 <P><I>Инициализация регистра контроля линии.</I> Значение битов регистра контроля линии, адрес порта которого равен 3FBH (или 2FBH), следующее:
<LI> 1-0 - длина символа (00 = 5 битов, 01 = 6 битов 10 = 7 битов, 11 = 8 битов) 
<LI> 2 - число стоп-битов (0 = 1, 1 = 1.5, если длина пяти, иначе 2) 
<LI> 3 - четность (1 = генерируется бит четности, 0 = нет). 
<LI>· 4 - тип четности(0 = нечетная, 1 = четная)
<LI> 5 - фиксация четности, заставляет бит четности всегда быть 0 или 1 (0 = отменена 
1 = всегда 1, если бит 3 = 1 & бит 4 = 0 или 1 = всегда 0, если бит 3 = 1 & бит 4 = 1 или 1 = нет четности, если бит 3 = 0) 
<LI> 6- установка перерыва. Вызывает вывод строки нулей в качестве сигнала отдаленной станции. 0 = запрещено, 1 = перерыв 
<LI> 7 - меняет адреса портов других регистров (обычно биты 5-7 сброшены в 0)                    Остальные описывают значения, определяемые протоколом обмена. Регистр разрешения прерывания. Даже если  не используются прерывания, все равно необходимо должны произвести запись в регистр разрешения прерывания, чтобы быть уверенным, что прерывания запрещены. Надо поместить в этот регистр 0. Регистр идентификации прерывания можно игнорировать. Инициализация остальных регистров связана с модемами. Ясно, что модемы нужны только для связи с удаленными устройствами, а не для управления близлежащими устройствами, такими как последовательный принтер. 
<P>В данном примере из области данных BIOS берется базовый адресCOM1, после чего различные регистры инициализируются для скорости обмена 1200 бод, семибитных данных, четной четности и одного стоп-бита.
<P>;---получаем базовый адрес COM1
<P> MOV AX,40H ;ES указывает на область данных BIOS 
<P>MOV ES,AX ; 
<P>MOV DX,ES:[0] ;получаем базовый адрес COM1
<P>;---инициализируеи регистры делителя скорости обмена на 1200 бод 
<P>ADD DX,3 ;указываем на регистр контроля линии 
<P>MOV AL,10000000B ;устанавливаем бит 7 
<P>OUT DX,AL ;посылаем байт 
<P>DEC DX ;указываем на старший байт делителя 
<P>DEC DX ;скорости обмена 
<P>MOV AL,0 ;старший байт для 1200 бод 
<P>OUT DX,AL ;посылаем старший байт для 1200 бод 
<P>DEC DX ;указываем на младший байт делителя 
<P>MOV AL,60H ;младший байт делителя для 1200 бод 
<P>OUT DX,AL ;посылаем младший байт 
<P>;---инициализируем регистр контроля линии 
<P>MOV AL,0 ;обнуляем 
<P>AL OR AL,10B ;длина данных 7 битов 
<P>OR AL,000B ;1 стоп-бит 
<P>OR AL,1000B ;генерируется бит четности 
<P>OR AL,10000B ;четная четность 
<P>ADD DX,3 ;указывает на регистр контроля линии 
<P>OUT DX,AL ;посылаем инициализационное значение
<P>;---инициализируем регистр разрешения прерывания 
<P>DEC DX ;указываем на регистр разрешения 
<P>DEC DX ;прерывания 
<P>MOV AL,0 ;запрещаем прерывания 
<P>OUT DX,AL ; посылаем байт

<P><I>Передача данных.</I> Передача данных проще, чем прием, поскольку программа имеет полный контроль над составом данных и скоростью, с которой они должны посылаться. Тем не менее, процедуры передачи могут быть достаточно сложными, если они обрабатывают данные по мере того, как они посылаются.  
<P>Функция 1 прерывания 14h BIOS посылает символ, содержащийся в AL в коммуникационный канал. При входе DX содержит номер порта (0или 1). При возврате AH содержит байт статуса, в котором бит 7 =1, если операция не успешна. В этом случае имеют значение следующие биты:
<LI>4 - обнаружен перерыв (сигнал "стоп" от принимающей станции);
<LI>5 - регистр сдвига передатчика пуст;
<LI>6 - регистр хранения передатчика пуст.
<P>MS DOS имеет функцию для передачи по коммуникационному каналу символа, помещаемого в DL. Это функция номер 4 прерывания 21h, но она не имеет никаких преимуществ перед функцией BIOS. Она не возвращает статусной информации и не позволяет назначать, какой из коммуникационных портов надо использовать (всегда используется COM1). Чтобы вывести строку данных используется функция 40h прерывания 21h. Это обычная функция вывода для всех файлов и устройств при использовании метода доступа дескриптора файлов. COM1 имеет предопределенный номер 3. Необходимо поместить номер файла в BX, а число передаваемых байтов в CX, 
DS:DX должен указывать на буфер выводимых данных, и вызывать функцию. 

<P>mov ah,40h               ;номер функции 
<P>mov bx,3                   ;предопределенный номер файла для COM1
<P>mov cx,50                 ;выводим 50 байтов 
<P>lea dx,data_buffer     ;DS:DX указывают на буфер данных
<P>int 21h                       ;посылаем данные 
<P>jc com_error             ;уход на обработку ошибки

<P>При использовании предопределенных номеров файлов их не надо открывать. Если произошла ошибка, то устанавливается флаг переноса, а в AX возвращается 5, если коммуникационный порт не готов, и 6, при указании неверного номера файла. 
<P>Kогда байт данных помещается в регистр хранения передатчика, то он автоматически выводится в последовательный канал через регистр сдвига передатчика, который сериализует данные. Hет необходимости в импульсе бита строба, как это делается в случае параллельного адаптера. Бит 5 регистра статуса линии показывает свободен ли регистр хранения передатчика для приема данных. Регистр постоянно проверяется до тех пор, пока бит 5 не станет равным 1. После этого в регистр хранения передатчика посылается очередной байт из того места, откуда они берутся. В процессе передачи бит 5 равен 0 и только когда он опять станет равным 1,то в регистр хранения передатчика может быть послан следующий символ. Этот процесс повторяется до тех пор, пока это нужно. В следующем примере даны основные понятия об этой процедуре. Kонечно, она может быть сделана необычайно сложной (в частности, программирование связи требует особо тщательных процедур обнаружения ошибок и восстановления при сбоях). В примере предполагается, что коммуникационный порт и модем уже инициализированы. Первая часть это цикл проверки ошибок и приема символов. 
<P>;---ждем пока все будет готово для посылки символа 
<P>KEEP_TRYING: 
<P>MOV DX,BASE_ADDRESS ;базовый адрес 
<P>ADD DX,5 ;указываем на регистр статуса линии 
<P>IN AL,DX ;получаем байт статуса 
<P>TEST AL,00011110B ;проверяем на ошибку 
<P>JNZ ERROR_ROUTINE ;если есть, то на процедуру обработки 
<P>TEST AL,00000001B ;проверяем получены ли данные 
<P>JNZ RECEIVE ;если да, то на процедуру приема 
<P>TEST AL,00100000B ;проверяем готовность к передаче 
<P>JZ KEEP_TRYING ;если нет, то возвращаемся назад
<P>;---передаем символ принимаемый с клавиатуры
<P> MOV AH,1 ;функция проверки нажатия клавиши 
<P>INT 16H ;прерывание клавиатуры 
<P>BIOS JZ KEEP_TRYING ;возврат, если не было нажатия 
<P>MOV AH,0 ;функция получения кода с клавиатуры 
<P>INT 16H ;теперь нужный символ в AL 
<P>SUB DX,5 ;адрес регистра хранения передатчика 
<P>OUT DX,AL ;посылаем символ 
<P>JMP SHORT KEEP_TRYING ;возвращаемся к началу цикла 

<P><I>Получение данных.</I> Коммуникационная программа готова принимать данные, как только инициализирован коммуникационный порт  и установлена связь с удаленной станцией. Прием данных никогда полностью не отделен от передачи данных, поскольку программе может потребоваться послать сигнал, чтобы остановить поток данных, если они поступают слишком быстро и она не успевает их обрабатывать. В зависимости от сложности используемого протокола обмена, принимаемые данные могут требовать простой или сложной обработки. 
<P>Функция 2 прерывания 14h BIOS ожидает символ из последовательного порта, помещает его в AL при получении и затем возвращается в программу. При входе надо поместить номер порта (0-1) в DX. При возврате AX равен нулю, если не было ошибки. Если AH не равен 0,то может быть возвращен байт статуса, в котором имеют значение только 5 битов. Это следующие биты:
<LI> 1 - ошибка переполнения (новый символ поступил раньше, чем был удален старый);
<LI>2 - ошибка четности (вероятно, из-за проблем в линии);
<LI>3 - ошибка оформления (стартовый или стоп-биты неверны);
<LI>4 - обнаружен перерыв (получена длинная строка битов 0);
<LI>5 - ошибка таймаута (не получен сигнал DSR).
<P>MS DOS также предоставляет коммуникационную функцию для приема одного символа, это функция 3 прерывания 21h. Функция ожидает символ из COM1 и помещает его в AL. По умолчанию порт инициализируется со значениями 2400 бод, нет контроля четности, один стоп-бит и 8 битов на символ. Эта функция не имеет никаких достоинств по сравнению с функцией BIOS и не возвращает информации о статусе.
<P>При получении данных без использования коммуникационного прерывания  программа должна постоянно проверять регистр статуса линии, адрес порта которого на 5 больше базового адреса используемого коммуникационного адаптера. Бит 0 этого регистра будет равен нулю, до тех пор, пока не будет получен символ в регистр данных приемника. Когда бит 0 становится равным 1, то надо немедленно считать его из регистра, с тем чтобы на него не наложился следующий принимаемый символ. После того, как символ считан, бит 0 опять становится равным 0 и остается таковым, пока не прибудет новый символ. Если поступающие данные подавать на экран со скоростью1200 бод, то процедура сдвига экрана BIOS  не будет успевать и произойдет переполнение. Простое решение этих проблем состоит в использовании коммуникационного прерывания. 
<P>KEEP_TRYING: 
<P>MOV DX,BASE_ADDRESS ;базовый адрес 
<P>ADD DX,5 ;указываем на регистр статуса линии 
<P>IN AL,DX ;получаем байт статуса 
<P>TEST AL,00011110B ;проверяем на ошибку 
<P>JNZ ERROR_ROUTINE ;если да, то на обработку ошибки 
<P>TEST AL,00000001B ;проверяем получены ли данные 
<P>JNZ RECEIVE ;на процедуру приема данных 
<P>TEST AL,00100000B ;проверяем готовность к передаче 
<P>JZ KEEP_TRYING ;если нет, то к началу цикла . 
<P>(здесь расположена процедура передачи)
<P> .;---получаем данные и выводим их на экран
<P>RECEIVE: MOV DX,BASE_ADDRESS ;базовый адрес 
<P>IN AL,DX ;читаем полученный символ 
<P>CMP AL,19 ;проверка на XOFF 
<P>JE XOFF_ROUTINE ; . (и т.д.) . 
<P>MOV DL,AL ;готовим символ для вывода на экран 
<P>MOV AH,2 ;функция вывода символа 
<P>INT 21H ;выводим его 
<P>JMP SHORT KEEP_TRYING ;возвращаемся на начало цикла

<P><B><I>Параллельный порт.</I> </B>
<I>Управление работой принтера.</I> MS DOS может работать с тремя параллельными устройствами (LPT1- LPT3). Каждое параллельное устройство имеет свой адаптер. Адаптер управляется тремя регистрами ввода/вывода и адреса портов этих регистров различны для каждого адаптера. Область данных BIOS содержит базовые адреса для каждого адаптера. Базовый адрес соответствует младшему адресу группы из трех адресов портов. Базовый адрес для LPT1 -0040:0008, для LPT2 - 0040:000A и т.д. Какой адаптер назначен какому номеру LPT - не определено. По этой причине программа,  которая прямо адресуется в параллельный порт, должна выискивать адреса, которые он использует. При инициализации базовому адресу присваивается значение 0, когда соответствующий адаптер не установлен. 
<P>Регистр выходных данных - это тот адрес порта, через который проходит каждый байт данных, посылаемый в принтер. Регистр статуса сообщает различную информацию о принтере; процессор может постоянно опрашивать его, чтобы распознать момент, когда все в порядке и можно посылать данные. Регистр статуса сообщает также, что произошла ошибка на принтере. Регистр управления инициализирует адаптер и управляет выводом данных. Он может также подготавливать параллельный порт для операций прерывания, с тем, чтобы принтер посылал прерывание к процессору, когда он готов к приему очередного символа, оставляя процессор свободным для других дел. 
<P>Ниже приведены значение битов регистров статуса и управления : 
<LI> регистр управления 
бит 0 (0 -  нормальная установка, 1 - вызывает вывод байта данных )
бит 1 (0 - нормальная установка, 1 - автоматический перевод строки после возврата каретки)
бит 2 (0 - инициализировать порт принтера, 1 - нормальная установка)
бит 3 (0 - отмена выбора принтера, 1 - нормальная установка)
бит 4 (0 - прерывание принтера запрещено, 1 - разрешено)
биты 5-7 не используются
<LI> регистр статуса 
биты 0-2 не используются 
бит 3 (0 -  ошибка принтера, 1 - нет ошибки)
бит 4  (0 - принтер off-line, 1 - принтер on-line )
бит 5 (0 - бумага вставлена, 1 - нет бумаги )
бит 6 (0 - принтер подтверждает прием символа, 1 - нормальная установка)
бит 7 (0 - принтер занят, 1 - принтер свободен) 
<P>Не имеется никаких оснований, чтобы любая программа не имела процедуру восстановления при ошибках, возникающих при работе с принтером. Хорошо написанная программа должна начинать с проверки того, что принтер связан с машиной (on line). Если присоединен не один принтер, то программа должна позволять пользователю выбрать с каким из них он будет работать. Кроме того, эта процедура должна восстанавливать ситуацию при любых ошибках принтера, при этом хотелось бы, чтобы не было необходимости снова печатать весь документ.
<P><I>Инициализация порта принтера. </I>Программы должны инициализировать порт каждого принтера (LPT1- LPT3) перед первым использованием принтера. Порты принтера должны также повторно инициализироваться после устранения причин ошибки принтера. Инициализацию порта принтера - это не инициализацией самого принтера. Инициализация принтера это внутреннее дело принтера. Она происходит автоматически при его включении и в большинстве случаев принтер не может быть повторно инициализирован без его выключения и повторного включения. Но программа может повторно инициализировать принтер, в том смысле, что могут быть восстановлены начальные параметры, которые принтер использует для печати, отменяя все специальные шрифты, остановы табуляции и т.д. Считается правилом хорошего тона производить такой сброс принтера, когда программа завершает работу с ним. Языки высокого уровня инициализируют порт принтера автоматически, но программы на языке ассемблера требуют для этой цели короткую процедуру.
<P>Восстановление начальных параметров печати требуется во всех программах. Некоторые принтеры имеют "главный код сброса", который приводит к полному сбросу принтера. Но поскольку не все принтеры имеют такой код, то программа должна предусматривать в своей завершающей части восстановление всех измененных параметров. Например, она может подать коды выключения курсива, выключения плотной печати и т.д. На многих принтерах символы не печатаются до тех пор, пока не получен код возврата каретки, завершающий строку (или до тех пор пока не введена целая строка данных). Символы могут спокойно ожидать в буфере принтера, даже после того, как породившая их программа завершилась. Когда начинается новая передача данных на принтер, то эти символы будут напечатаны. Чтобы избежать этой проблемы, необходимо почистить буфер перед началом печати; а в качестве правил хорошего тона, надо чистить буфер также при завершении программы. Это делается посылкой на принтер кода ASCII 24 (при этом параметры печати не меняются). 
<P>Функция 1 прерывания 17h BIOS инициализирует порт принтера и возвращает байт, дающий статус порта. Необходимо поместите в DX номер порта - число от 0 до 2 для LPT1 - LPT3, после чего вызвать прерывание. Байт статуса принтера возвращается в AH.

<P>;инициализация LPT1
<P>mov ah,1         ;функция инициализации принтера 
<P>mov dx,0         ;LPT1 
<P>int 17h             ;проводим инициализацию 

<P>Регистр управления выводом каждого адаптера принтера имеет бит, который вызывает инициализацию адаптера. Этот регистр имеет адрес порта на 2 больше, чем базовый адрес адаптера. Базовый адрес для LPT1 хранится в ячейке 0040:0008, для LPT2- в 0040:000A и т.д. Имеют значение только младшие 5 битов регистра управления выводом. Бит 2 - бит инициализации принтера и обычно он устанавливается в 1. Для инициализации адаптера надо сбросить этот бит в 0 на тысячу тактов пустого цикла (3000 для AT или на 1/20 секунды, используя счетчик времени суток BIOS). В этот момент нужно, чтобы был установлен только бит 3 (принтер выбран). Поэтому надо послать в порт значение 12, сделать задержку, а затем послать в порт обычное (без прерываний) не инициализационное значение, которое равно 8. В данном примере инициализируется LPT1:
<P>;---инициализируем 
<P>LPT1 MOV DX,ES:[8] ;считываем базовый адрес в DX 
<P>INC DX ;прибавляем 2 к базовому адресу 
<P>INC DX ; MOV AL,12 ;значение для инициализации 
<P>OUT DX,AL ;начинаем инициализацию
<P>DELAY: MOV AX,1000 ;начало пустого цикла 
<P>DEC AX ;уменьшаем счетчик 
<P>JNZ DELAY ;повторяем 1000 раз 
<P>MOV AL,8 ;обычное значение для регистра 
<P>OUT DX,AL ;конец инициализации

<P><I>Посылка данных на принтер.</I> Посылка данных на принтер тривиальна в языках высокого уровня, а для программиста на языке ассемблера имеется ряд функций операционной системы, которые делают задачу также достаточно простой. Программирование на низком уровне требует больше работы, но зато предоставляет больше возможностей. Как правило, процедуры печати низкого уровня посылают символ на принтер, а затем постоянно проверяет регистр статуса ввода порта, к которому присоединен принтер. Следующий символ посылается только тогда, когда принтер сигнализирует, что он готов (принтер может не печатать символ сразу, а запасать его в своем буфере, до тех пор, пока не будет получена целая строка символов для печати). Кроме того, процедуры низкого уровня могут использовать прерывание принтера или могут имитировать действие этого прерывания. С помощью специального программирования можно сделать так, что принтер будет делать прерывание процессора, когда он готов к приему следующего символа. Процедура обработки прерывания посылает следующий символ, после чего процессор может продолжать заниматься своими делами. Этот метод используется для фоновой печати. Поскольку физические перемещения деталей принтера намного медленнее, чем скорость электроники компьютера, то вывод символов на принтер занимает лишь малую долю процессорного времени. Использование прерывания позволяет использовать это время эффективно. При посылке данных на принтер требуется сравнительно небольшие усилия, чтобы добиться ужасно сложного вывода. Все сложные картинки, которые может выводить принтер, достигаются за счет комбинирования текстовых и графических данных, а также многочисленных кодов управления принтером.
<P>Комбинируя в одной строке текстовый и графический режимы, можно добиться выравнивания правого поля и пропорциональной печати. Кроме того, любой графический принтер может создавать специальные символы произвольного вида, а за счет аккуратного манипулирования надпечатки и межстрочного интервала могут выводиться любые символы псевдографики. 
<P><I>Вывод текстовых или графических данных на принтер. </I>Процессор может заниматься только посылкой данных на принтер или он может печатать в фоновом режиме, за счет использования прерывания принтера. Возможна и третья альтернатива, когда программа посылает символы на принтер через определенные интервалы, что можно рассматривать как "псевдопрерывание". Этот метод не так тесно координируется с работой принтера, как настоящее прерывание, но, во всяком случае, работа принтера не критична ко времени. Независимо от того, как выводятся данные, каждый раз на принтер посылается только 1 байт данных. Языки высокого уровня предоставляют функции, которые вроде бы выводят сразу целые строки, однако на самом деле эти функции разбивают строки на отдельные символы. Обычно языки высокого уровня посылают на принтер пару возврат каретки/перевод строки в конце каждой строки. Программы на ассемблере должны сами добавлять эту пару кодов. Из-за этого приходится немного больше программировать, но взамен получается намного большая гибкость, особенно в отношении проверки ошибок. 
<P>Функция 0 прерывания 17h посылает один символ на принтер. Символ помещается в AL, а номер принтера - в DX. При возврате AH будет содержать регистр статуса, который надо постоянно проверять для обнаружения ошибок. 
<P>Для вывода потока данных необходимо установить указатель на буфер, содержащий данные, и написать следующую процедуру:
<P>;---вывод данных на LPT1
<P><P>mov cx, number_chars              ;CX содержит число байт для вывода 
<P>mov dx,0                                   ;выбираем LPT1NEXT_CHAR:
<P>mov ah,0                                   ;функция посылки символа на принтер 
<P>mov al,[bx]                               ;BX указывает на буфер данных 
<P>int 17h                                       ;посылаем символ
<P>test ah ,8                                   ;проверяем бит ошибки 
<P>jnz printr_error                         ;на обработку ошибки 
<P>inc bx                                        ;увеличиваем указатель 
<P>loop next_char                          ;выводим следующий символ

<P>Стандартное прерывание MS DOS для вывода на принтер это функция 5 прерывания 21h. Необходимо поместить символ в DL и выполнить прерывание. Эта функция всегда выводит на LPT1 и у нее нет возвращаемых регистров.
<P>mov ah,5                  ;номер функции 
<P>mov dl,char     ;готовим печатаемый символ
<P>int 21h ;посылаем его на принтер
<P>Другой способ вывода данных на принтер это функция 40h прерывания 21h. Это функция стандартного вывода, с использованием метода дескриптора файлов для доступа к файлу или устройству. В данном случае эта функция использует специальный предопределенный номер файла для принтера. Этот номер 4 и его надо поместить в BX. Функция имеет доступ только к LPT1, поэтому для вывода на другой принтер надо поменять базовые адреса. DS:DX должны указывать на выводимые данные, а CX содержать число посылаемых байтов. Например:
<P>;вывод 120 байтов данных на LPT1
<P>mov ah,40h           ;номер функции 
<P>mov bx,4           ;номер файла для принтера 
<P>mov cx,120       ;число посылаемых байтов 
<P>lea dx,prtr_data ;DS:DX указывают на данные 
<P>int 21h ;посылаем данные 
<P>jc prtr_error ;на обработку ошибки

<P>При возврате установленный флаг переноса индицирует ошибку, при этом AX будет содержать 5, если принтер не связан с машиной, и 6 - если указан неверный номер файла. 
<P>Байт данных посылается на принтер, путём посылки его в регистр выводимых данных, адрес порта которого совпадает с базовым адресом принтера. После того как данные посланы в регистр на короткое время включается бит строба регистра управления выводом, адрес порта которого на 2 больше, чес регистра данных. Номер бита строба равен 0 и он должен быть установлен только на очень короткое время, чтобы инициировать передачу данных, находящихся в регистре данных.
<P>Далее программа должна ожидать, пока принтер не сообщит, что он готов к приёму следующего байта. При готовности принтер даёт импульс в бит подтверждения регистра статуса ввода, адрес порта которого на 1 больше базового адреса принтера. Номер бита подтверждения равен 6 и обычно он установлен в 1. Импульс подтверждения сбрасывает этот бит в 0 на достаточно долгое время, чтобы программа могла увидеть это, если она следит за регистром.
<P>Другой способ узнать, что принтер готов к приёму следующего байта данных состоит в непрерывной проверке бита 7 регистра статуса, который сбрасывается в 0, когда принтер занят.
<P>Следующий пример получает базовый адрес LPT1  из области данных BIOS  и затем выводит данные из буфера, на который указывает регистр BX. Программа постоянно проверяет регистр статуса на занятость и одновременно проверяет бит 3, чтобы проверить наличие ошибки на принтере:
<P>:---подготовка
<P>mov ax,40h           ;es указывает на область данных BIOS
<P>mov es,ax
<P>mov dx,es[8]         ;базовый адрес в DX
<P>mov bx,data_start  ;BX указываетн на буфер данных
<P>;---посылаем символ
<P>next:
<P>mov al,[bx]           ;символ в AL
<P>out dx,al               ;посылаем символ
<P>inc dx                   ;DX будет указывать на 
<P>inc dx                   ;регистр управления выводом
<P>mov al,13             ;цепочка битов для импульса строба
<P>out dx,al               ;посылаем сигнал строба
<P>dec al                    ;нормальное состояние регистра
<P>out dx,al               ;посылаем его
<P>dec dx;
<P>not_yet:
<P>in al,8;
<P>jnz error;
<P>test al,80h;
<P>jz not_yet;
<P>inc bx                  ;увеличиваем указатель в буфере данных
<P>dec dx                 ;указывает на регистр данных
<P>jmp next;

<H4><I></I></H4>
<P><B>2 Порядок выполнения работы</B>
<P>1.Ознакомиться с теоретическим материалом, приведённым в методических указаниях.
<P>2.Запустить на выполнение пример и ознакомиться с демонстрационными программами.
<P>3.Получить у преподавателя номер варианта и задание по нему, которое приведено в лабораторном комплексе.
<P>4.Разработать предварительный алгоритм программы.
<P>5.В текстовом редакторе  ввести текст исходной программы.
<P>6.Запустить на выполнение программу TASM.EXE, если есть ошибки, то вернуться к пункту 4.
<P>7.Запустить на выполнение программу TLINK.EXE, если есть ошибки, то вернуться к пункту 4.
<P>8.Запустить на выполнение программу TD.EXE, если есть ошибки, то вернуться к пункту 4.
<P>9. Получить контрольные вопросы.
<P>10.Подготовить ответы на вопрсы.
<P>11.Оформить отчёт.
<P>12.Защитить лабораторную работу.

</html>